#include <PalmOS.h>

#include "sys.h"
#include "mutex.h"
#include "pwindow.h"
#include "vfs.h"
#include "bytes.h"
#include "emupalmosinc.h"
#include "AppRegistry.h"
#include "storage.h"
#include "pumpkin.h"
#include "debug.h"
#include "xalloc.h"

#define PALMOS_MODULE "Category"

#include "debug.h"

/*
typedef struct AppInfoTag {
  UInt16 renamedCategories;
  Char  categoryLabels [dmRecNumCategories] [dmCategoryLength];
  UInt8 categoryUniqIDs[dmRecNumCategories];
  UInt8 lastUniqID; // Uniq IDs generated by the device are between 0 - 127.  Those from the PC are 128 - 255.
  UInt8 padding;
} AppInfoType;
*/

static UInt32 sdup(char *s) {
  uint8_t *p;
  UInt32 len, w = 0;

  if (s && s[0]) {
    len = StrLen(s);
    if ((p = pumpkin_heap_alloc(len + 1, "cat_itenstext")) != NULL) {
      MemSet(p, len, 0);
      MemMove(p, s, len);
      w = p - emupalmos_ram();
    }
  }

  return w;
}

void CategoryCreateListV10(DmOpenRef db, ListType *lst, UInt16 currentCategory, Boolean showAll) {
  CategoryCreateList(db, lst, currentCategory, showAll, false, 0, categoryHideEditCategory, true);
}

void CategoryCreateList(DmOpenRef db, ListType *listP, UInt16 currentCategory, Boolean showAll, Boolean showUneditables, UInt8 numUneditableCategories, UInt32 editingStrID, Boolean resizeList) {
  LocalID appInfoID;
  MemHandle h, editHandle;
  AppInfoType *appInfo;
  Char *editStr, **itemsText;
  UInt16 numItems, index;
  UInt32 w, *aux32;

  IN;
  if (db && listP) {
    if ((appInfoID = DmGetAppInfoID(db)) != 0) {
      h = MemLocalIDToHandle(appInfoID);
      if ((appInfo = MemHandleLock(h)) != NULL) {
        numItems = 0;
        itemsText = MemPtrNew((dmRecNumCategories+2) * sizeof(Char *)); //+1 for "All", +1 for "Edit categories"
        if (showAll) {
          // #define categoryAllStrID   10004
          itemsText[numItems++] = "All";
          currentCategory++;
        }
        for (index = 0; index < dmRecNumCategories; index++) {
          if (appInfo->categoryLabels[index][0] == 0) break;
          debug(DEBUG_TRACE, PALMOS_MODULE, "CategoryCreateList text %d \"%s\"", numItems, appInfo->categoryLabels[index]);
          itemsText[numItems++] = appInfo->categoryLabels[index];
        }

        editHandle = NULL;
        editStr = NULL;
        if (editingStrID == 0 || editingStrID == categoryDefaultEditCategoryString) {
          // #define categoryEditStrID  10005
          editStr = "Edit Categories\x85";
        } else if (editingStrID != categoryHideEditCategory) {
          if ((editHandle = DmGetResource(strRsc, editingStrID)) != NULL) {
            editStr = MemHandleLock(editHandle);
          }
        }
        if (editStr) {
          itemsText[numItems++] = editStr;
        }

        if (numItems > 0) {
          if (pumpkin_is_m68k()) {
            aux32 = MemPtrNew((dmRecNumCategories+2) * sizeof(UInt32));
            for (index = 0; index < numItems; index++) {
              w = sdup(itemsText[index]);
              put4b(w, (uint8_t *)(&aux32[index]), 0);
            }
            LstSetListChoices(listP, (char **)&aux32[0], numItems);
            MemPtrFree(itemsText);
          } else {
            LstSetListChoices(listP, itemsText, numItems);
          }

          LstSetSelection(listP, currentCategory);
          if (resizeList) {
            LstSetHeight(listP, numItems);
          }
        }

        if (editHandle) {
          MemHandleUnlock(editHandle);
          DmReleaseResource(editHandle);
        }
        MemHandleUnlock(h);
      }
    }
  }
  OUTV;
}

void CategoryFreeListV10(DmOpenRef db, ListType *lst) {
  CategoryFreeList(db, lst, true, categoryHideEditCategory);
}

void CategoryFreeList(DmOpenRef db, ListType *listP, Boolean showAll, UInt32 editingStrID) {
  IN;
  if (db && listP) {
    LstFreeListChoices(listP);
  }
  OUTV;
}

UInt16 CategoryFind(DmOpenRef db, const Char *name) {
  LocalID appInfoID;
  MemHandle h;
  AppInfoType *appInfo;
  UInt16 index, r = dmAllCategories;

  IN;
  if (db && name && (appInfoID = DmGetAppInfoID(db)) != 0) {
    h = MemLocalIDToHandle(appInfoID);
    if ((appInfo = MemHandleLock(h)) != NULL) {
      for (index = 0; index < dmRecNumCategories; index++) {
        if (StrNCompare(name, appInfo->categoryLabels[index], dmCategoryLength) == 0) {
          r = index;
          break;
        }
      }
      MemHandleUnlock(h);
    }
  }
  OUTV;

  return r;
}

void CategoryGetName(DmOpenRef db, UInt16 index, Char *name) {
  LocalID appInfoID;
  MemHandle h;
  AppInfoType *appInfo;

  IN;
  if (db && name) {
    if (index == dmAllCategories) {
      StrNCopy(name, "All", dmCategoryLength); // XXX is this correct ?
    } else if (index < dmRecNumCategories && (appInfoID = DmGetAppInfoID(db)) != 0) {
      h = MemLocalIDToHandle(appInfoID);
      if ((appInfo = MemHandleLock(h)) != NULL) {
        StrNCopy(name, appInfo->categoryLabels[index], dmCategoryLength);
        MemHandleUnlock(h);
      }
    }
  }
  OUTV;
}

Boolean CategoryEditV10(DmOpenRef db, UInt16 *category) {
  return CategoryEdit(db, category, categoryDefaultEditCategoryString, 0);
}

Boolean CategoryEditV20(DmOpenRef db, UInt16 *category, UInt32 titleStrID) {
  return CategoryEdit(db, category, titleStrID, 0);
}

// This function both displays the Edit Categories dialog and handles
// the result of the user actions. It updates the AppInfoType
// structure's list of categories and reassigns database records to new
// categories as needed. If a user deletes a category, CategoryEdit
// moves all of the records belonging to that category to the Unfiled
// category. If a category is renamed to be the same as an existing
// category, this function moves all of the old category's records to the new category.

Boolean CategoryEdit(DmOpenRef db, UInt16 *category, UInt32 titleStrID, UInt8 numUneditableCategories) {
  FormType *frm, *previous;
  ListType *list;
  UInt16 index;
  MemHandle h = NULL;
  char *title = NULL;
  Boolean r = false;

  frm = FrmInitForm(CategoriesEditForm); // edit categories dialog

  if (titleStrID != categoryDefaultEditCategoryString) {
    if ((h = DmGetResource(strRsc, titleStrID)) != NULL) {
      if ((title = MemHandleLock(h)) != NULL) {
        FrmSetTitle(frm, title);
      }
    }
  }

  index = FrmGetObjectIndex(frm, CategoriesEditList);
  if ((list = FrmGetObjectPtr(frm, index)) != NULL) {
    CategoryCreateList(db, list, 0, false, numUneditableCategories > 0, numUneditableCategories, categoryHideEditCategory, false);
  }

  previous = FrmGetActiveForm();
  if (FrmDoDialog(frm) == CategoriesEditOKButton) { // "OK" button
    // XXX
  }

  if (list) {
    CategoryFreeList(db, list, false, categoryHideEditCategory);
  }

  if (h) {
    if (title) {
      FrmSetTitle(frm, NULL);
      MemHandleUnlock(h);
    }
    DmReleaseResource(h);
  }

  FrmDeleteForm(frm);
  FrmSetActiveForm(previous);

  return r;
}

Boolean CategorySelectV10(DmOpenRef db, const FormType *formP, UInt16 ctlID, UInt16 lstID, Boolean title, UInt16 *categoryP, Char *categoryName) {
  return CategorySelect(db, formP, ctlID, lstID, title, categoryP, categoryName, 0, categoryHideEditCategory);
}

Boolean CategorySelect(DmOpenRef db, const FormType *formP, UInt16 ctlID, UInt16 lstID, Boolean title, UInt16 *categoryP, Char *categoryName, UInt8 numUneditableCategories, UInt32 editingStrID) {
  ListType *list;
  ControlType *ctl;
  UInt16 listIndex, trigIndex;
  Int16 selection, prev;
  Boolean r = false;

  // Call this function when the user taps the category popup trigger.
  // This function handles all aspects of displaying the popup list and managing the user selection:
  // - creates the popup list using CategoryCreateList
  // - displays the popup list
  // - calls CategoryEdit if the user selects the Edit Categories item
  // - uses CategorySetTriggerLabel to set the trigger label to the item the user selected
  // - calls CategoryFreeList to free the list items array

  IN;
  if (formP && categoryP) {
    listIndex = FrmGetObjectIndex(formP, lstID);
    trigIndex = FrmGetObjectIndex(formP, ctlID);

    if (listIndex != frmInvalidObjectId && trigIndex != frmInvalidObjectId) {
      if ((list = FrmGetObjectPtr(formP, listIndex)) != NULL) {
        CategoryCreateList(db, list, *categoryP, title, numUneditableCategories > 0, numUneditableCategories, editingStrID, true);
        prev = LstGetSelection(list);
        selection = LstPopupList(list);

        if (selection != -1) {
          if (editingStrID != categoryHideEditCategory && selection == LstGetNumberOfItems(list) - 1) {
            r = CategoryEdit(db, categoryP, categoryDefaultEditCategoryString, numUneditableCategories);

            if ((ctl = FrmGetObjectPtr(formP, trigIndex)) != NULL) {
              CategorySetTriggerLabel(ctl, LstGetSelectionText(list, prev));
            }

          } else {
            if (title) {
              if (selection == 0) {
                *categoryP = dmAllCategories;
              } else {
                *categoryP = selection - 1;
              }
            } else {
              *categoryP = selection;
            }
            CategoryGetName(db, *categoryP, categoryName);
            if ((ctl = FrmGetObjectPtr(formP, trigIndex)) != NULL) {
              CategorySetTriggerLabel(ctl, categoryName);
            }
          }
        }

        CategoryFreeList(db, list, title, editingStrID);
      }
    }
  }
  OUTV;

  return r;
}

UInt16 CategoryGetNext(DmOpenRef db, UInt16 index) {
  LocalID appInfoID;
  MemHandle h;
  AppInfoType *appInfo;
  UInt16 count;

  IN;
  if (db && (appInfoID = DmGetAppInfoID(db)) != 0) {
    h = MemLocalIDToHandle(appInfoID);
    if ((appInfo = MemHandleLock(h)) != NULL) {
      for (count = 0, index++; count < dmRecNumCategories; count++) {
        if (index >= dmRecNumCategories) index = 0;
        if (appInfo->categoryLabels[index][0]) break;
      }
      MemHandleUnlock(h);
    }
  }
  OUTV;

  return index;
}

/*
  0: buttonCtl
  1: pushButtonCtl
  2: checkboxCtl
  3: popupTriggerCtl
  4: selectorTriggerCtl
  5: repeatingButtonCtl
  6: sliderCtl
  7: feedbackSliderCtl
*/

void CategorySetTriggerLabel(ControlType *ctl, Char *name) {
  UInt16 width, x;

  IN;
  if (ctl && name) {
    debug(DEBUG_TRACE, PALMOS_MODULE, "CategorySetTriggerLabel name=\"%s\" dx=%d style=%d frame=%d", name, ctl->bounds.extent.x, ctl->style, ctl->attr.frame);
    CategoryTruncateName(name, 72);
    debug(DEBUG_TRACE, PALMOS_MODULE, "CategorySetTriggerLabel truncated name=\"%s\"", name);

    width = FntCharsWidth(name, StrLen(name));
    if (width > ctl->bounds.extent.x) {
      x = ctl->bounds.topLeft.x + ctl->bounds.extent.x;
      ctl->bounds.topLeft.x = x - width;
      ctl->bounds.extent.x = width;
    }

    CtlSetLabel(ctl, name);
  }
  OUTV;
}

void CategoryTruncateName(Char *name, UInt16 maxWidth) {
  UInt16 len;


  IN;
  if (name && name[0]) {
    len = StrLen(name);
    if (FntCharsWidth(name, len) > maxWidth) {
      len = FntWidthToOffset(name, len, maxWidth - FntCharWidth(chrEllipsis), NULL, NULL);
      name[len] = chrEllipsis;
      name[len+1] = 0;
    }
  }
  OUTV;
}

void CategoryInitialize(AppInfoPtr appInfoP, UInt16 localizedAppInfoStrID) {
  MemHandle h;
  UInt16 index;
  char *s;

  // localizedAppInfoStrID: Resource ID of the localized category names. This must be a resource of the type appInfoStringsRsc ('tAIS').
  // Example tAIS resource from MemoPad application:
  // 0000: 55 6e 66 69 6c 65 64 00 42 75 73 69 6e 65 73 73   Unfiled.Business
  // 0010: 00 50 65 72 73 6f 6e 61 6c 00 00 00 00 00 00 00   .Personal.......
  // 0020: 00 00 00 00 00 00 00                              .......

  IN;
  if (appInfoP) {
    MemSet(&appInfoP->categoryLabels[0], dmRecNumCategories * dmCategoryLength, 0);

    if ((h = DmGetResource(appInfoStringsRsc, localizedAppInfoStrID)) != NULL) {
      if ((s = MemHandleLock(h)) != NULL) {
        for (index = 0; s[0] && index < dmRecNumCategories; index++) {
          debug(DEBUG_TRACE, PALMOS_MODULE, "CategoryInitialize %d: \"%s\"", index, s);
          DmStrCopy(appInfoP, OffsetOf(AppInfoType, categoryLabels[index]), s);
          s += StrLen(s)+1;
        }
        MemHandleUnlock(h);
      }
    }
  }
  OUTV;
}

void CategorySetName(DmOpenRef db, UInt16 index, const Char *nameP) {
  LocalID appInfoID;
  MemHandle h;
  AppInfoType *appInfo;

  IN;
  if (db && index < dmRecNumCategories && (appInfoID = DmGetAppInfoID(db)) != 0) {
    h = MemLocalIDToHandle(appInfoID);
    if ((appInfo = MemHandleLock(h)) != NULL) {
      if (nameP) {
        StrNCopy(appInfo->categoryLabels[index], nameP, dmCategoryLength);
      } else {
        MemSet(appInfo->categoryLabels[index], dmCategoryLength, 0);
      }
      MemHandleUnlock(h);
    }
  }
  OUTV;
}
